{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MCAP-Logger MCAP-Logger wraps the MCAP protobuf logging package with the Foxglove schemas to provide a standardised, easy to import and use logging method. PyPI Features Foxglove compatible log messages Creating MCAP log files ProtoBuf serialisation Python logging best practices Demo log in Foxglove Studio","title":"Home"},{"location":"#mcap-logger","text":"MCAP-Logger wraps the MCAP protobuf logging package with the Foxglove schemas to provide a standardised, easy to import and use logging method. PyPI","title":"MCAP-Logger"},{"location":"#features","text":"Foxglove compatible log messages Creating MCAP log files ProtoBuf serialisation Python logging best practices Demo log in Foxglove Studio","title":"Features"},{"location":"CHANGELOG/","text":"CHANGELOG v1.0.0 (2024-11-23) Kick out old MCAP logger interface. ( 8b57557 ) Make Topic attributes private and remove logger call from Topic. ( 58fb89b ) Attribute error when Topic writer is none. ( da33899 ) Add examples on how to use logging in application and library. ( 2c1ae97 ) Add example of using TopicLogger. ( 3ec195d ) Add example of using the McapHandler. ( ccdcfdd ) Create TopicLogger class to handle data logging. ( 5d5f9d6 ) Create a logging handler for MCAP files. ( 803fd42 ) Other Fix CI release builds older version ( ecd7018 ) Only publish to PyPI when new release is created ( 2582b2f ) Update links in README. ( 7868ace ) Add badges to README. ( 8966936 ) Fix documentation mistake. ( 26a7b8b ) Change documentation Header style. ( 1cbc35b ) Add tutorial on how to do library logging. ( 3a87810 ) Add tutorial to learn how to configure both console and MCAP logging for a logger. ( 0ef4494 ) Create updated documentation for using the TopicLogger. ( e6d2b2f ) Move integration test resources to tests folder. ( ef9d97c ) Add integration test for data logging with TopicLogger. ( 4c19bf1 ) Change Ruff configuration to exclude checks on ProtoBuf artifacts. ( 0c6cd16 ) Stop ignoring protobuf artifacts. ( 1c15b30 ) Add API reference for topic logger. ( 1e2f641 ) Document the TopicLogger with docstrings. ( 1b12767 ) Use time_ns() function instead of time(). ( 285b60c ) Move Topic class to the same script as TopicLogger. ( 93d9f15 ) Added documentation about how to create your first log with McapHandler. ( 26d3096 ) Update documentation of API references. ( a269048 ) add workflow for semantic versioning ( 124f1aa ) configure semantic-release ( 7e62d9d ) remove pypi-version dependency ( 4a5c631 ) remove pypi-version dependency ( 6412f83 ) v0.1.18 (2024-11-15) Other [pre-commit.ci] pre-commit autoupdate ( f1b7187 ) updates: - github.com/astral-sh/ruff-pre-commit: v0.7.2 \u2192 v0.7.3 [pre-commit.ci] pre-commit autoupdate ( f3a0192 ) updates: - github.com/pre-commit/pre-commit-hooks: v2.3.0 \u2192 v5.0.0 - github.com/astral-sh/ruff-pre-commit: v0.6.9 \u2192 v0.7.2 Ci: only trigger auto documentation on main branch ( 2be409c ) Chore: update project urls ( b1cc2fd ) Ci: auto publish documentation on github pages ( b0df5d8 ) Docs: create documentation with mkdocs ( fe86327 ) Docs: add tutorial for logging sensor data ( fad79de ) Docs: add tutorials for installation and first log creation ( 6a6b2c2 ) Docs: add github repo url link ( ebdde12 ) Ci: run testing only if python files are changed ( 71a1482 ) Fix: wrong indentation in publishing workflow ( 72feee2 ) Ci: add github workflow for publishing package ( 02b1a98 ) Ci: add github workflow for testing ( d57245f ) Ci: add test cases to the project ( 81b40a9 ) Chore: create LICENSE ( 60e9fa4 ) Docs: add documentation to the package ( a111f3c ) Fix: #2 console log shows the wrong function ( f5c4653 ) Chore: fix ruff errors ( c0b6fae ) Feat: log mcap messages on the console ( cf55a16 ) Feat: define default logging path ( a8e926a ) Refactor: change namings ( b66f0be ) Fix: wrong log level calls ( 1092efd ) Chore: add pre-commit and ruff formating ( 06ddc97 ) Feature: extend logging levels ( 698a3df ) Refactor: create MCAP logger class to handle logs and topics ( d78d49f ) Refactor: create classes for logs and topics ( 849dce6 ) Feat: sensor example with logging using protobuf ( 51330da ) Feat: use protobuf ( ba00e07 ) Feat: logging sample data into mcap file ( 43c56d1 )","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#v100-2024-11-23","text":"","title":"v1.0.0 (2024-11-23)"},{"location":"CHANGELOG/#_1","text":"Kick out old MCAP logger interface. ( 8b57557 ) Make Topic attributes private and remove logger call from Topic. ( 58fb89b )","title":""},{"location":"CHANGELOG/#_2","text":"Attribute error when Topic writer is none. ( da33899 )","title":""},{"location":"CHANGELOG/#_3","text":"Add examples on how to use logging in application and library. ( 2c1ae97 ) Add example of using TopicLogger. ( 3ec195d ) Add example of using the McapHandler. ( ccdcfdd )","title":""},{"location":"CHANGELOG/#_4","text":"Create TopicLogger class to handle data logging. ( 5d5f9d6 ) Create a logging handler for MCAP files. ( 803fd42 )","title":""},{"location":"CHANGELOG/#other","text":"Fix CI release builds older version ( ecd7018 ) Only publish to PyPI when new release is created ( 2582b2f ) Update links in README. ( 7868ace ) Add badges to README. ( 8966936 ) Fix documentation mistake. ( 26a7b8b ) Change documentation Header style. ( 1cbc35b ) Add tutorial on how to do library logging. ( 3a87810 ) Add tutorial to learn how to configure both console and MCAP logging for a logger. ( 0ef4494 ) Create updated documentation for using the TopicLogger. ( e6d2b2f ) Move integration test resources to tests folder. ( ef9d97c ) Add integration test for data logging with TopicLogger. ( 4c19bf1 ) Change Ruff configuration to exclude checks on ProtoBuf artifacts. ( 0c6cd16 ) Stop ignoring protobuf artifacts. ( 1c15b30 ) Add API reference for topic logger. ( 1e2f641 ) Document the TopicLogger with docstrings. ( 1b12767 ) Use time_ns() function instead of time(). ( 285b60c ) Move Topic class to the same script as TopicLogger. ( 93d9f15 ) Added documentation about how to create your first log with McapHandler. ( 26d3096 ) Update documentation of API references. ( a269048 ) add workflow for semantic versioning ( 124f1aa ) configure semantic-release ( 7e62d9d ) remove pypi-version dependency ( 4a5c631 ) remove pypi-version dependency ( 6412f83 )","title":"Other"},{"location":"CHANGELOG/#v0118-2024-11-15","text":"","title":"v0.1.18 (2024-11-15)"},{"location":"CHANGELOG/#other_1","text":"[pre-commit.ci] pre-commit autoupdate ( f1b7187 ) updates: - github.com/astral-sh/ruff-pre-commit: v0.7.2 \u2192 v0.7.3 [pre-commit.ci] pre-commit autoupdate ( f3a0192 ) updates: - github.com/pre-commit/pre-commit-hooks: v2.3.0 \u2192 v5.0.0 - github.com/astral-sh/ruff-pre-commit: v0.6.9 \u2192 v0.7.2 Ci: only trigger auto documentation on main branch ( 2be409c ) Chore: update project urls ( b1cc2fd ) Ci: auto publish documentation on github pages ( b0df5d8 ) Docs: create documentation with mkdocs ( fe86327 ) Docs: add tutorial for logging sensor data ( fad79de ) Docs: add tutorials for installation and first log creation ( 6a6b2c2 ) Docs: add github repo url link ( ebdde12 ) Ci: run testing only if python files are changed ( 71a1482 ) Fix: wrong indentation in publishing workflow ( 72feee2 ) Ci: add github workflow for publishing package ( 02b1a98 ) Ci: add github workflow for testing ( d57245f ) Ci: add test cases to the project ( 81b40a9 ) Chore: create LICENSE ( 60e9fa4 ) Docs: add documentation to the package ( a111f3c ) Fix: #2 console log shows the wrong function ( f5c4653 ) Chore: fix ruff errors ( c0b6fae ) Feat: log mcap messages on the console ( cf55a16 ) Feat: define default logging path ( a8e926a ) Refactor: change namings ( b66f0be ) Fix: wrong log level calls ( 1092efd ) Chore: add pre-commit and ruff formating ( 06ddc97 ) Feature: extend logging levels ( 698a3df ) Refactor: create MCAP logger class to handle logs and topics ( d78d49f ) Refactor: create classes for logs and topics ( 849dce6 ) Feat: sensor example with logging using protobuf ( 51330da ) Feat: use protobuf ( ba00e07 ) Feat: logging sample data into mcap file ( 43c56d1 )","title":"Other"},{"location":"how-to-guides/","text":"","title":"How-To Guides"},{"location":"explanations/foxglove/","text":"Foxglove helps robotics teams to explore, collaborate on, and make sense of their robots' data - for more intelligent iteration and accelerated development. Because of its capability of importing and streaming multimodal data (video, image, lidar sensor, etc.) and displaying them over its highly configurable layout, it is a good choice for robotics development. This is the reason why we are aiming to have full compatibility with its message schemas .","title":"Foxglove"},{"location":"explanations/mcap/","text":"MCAP is an open source container file format for multimodal log data. It is ideal for robotics applications, as it can record multiple streams of structured and unstructured data (e.g. ROS, Protobuf, JSON Schema, etc.) in a single file. It is the chosen file format because of its benefits and flexibility.","title":"MCAP"},{"location":"explanations/motivation/","text":"In the past we were relying on console printouts and unserialised log files to log the actions of our systems. As the complexity of the system increased, so did the amount and complexity of the logged data, and the previous approach was not feasible anymore. Fortunately, there is already solutions like MCAP and Foxglove , that combined with ProtoBuf allows us to make smaller sized logs with better traceability. Python packages like mcap-protobuf-support and foxglove-schemas-protobuf are nice implementations to achieve this. The goal of this package is... to create a logger handler that leverages the existing MCAP and Foxglove packages to leverage the configurability of Python to provide a plugin for standard Python loging","title":"Motivation"},{"location":"explanations/protobuf/","text":"Protocol Buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. It\u2019s like JSON, except it\u2019s smaller and faster, and it generates native language bindings. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. Protocol buffers are a combination of the definition language (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, the serialization format for data that is written to a file (or sent across a network connection), and the serialized data. Some of the advantages of using protocol buffers include: Compact data storage Fast parsing Availability in many programming languages Optimized functionality through automatically-generated classes Because of its strict definition of the interface of the data, it is a good choice for making sure that the created logs adhere to Foxglove's schemas .","title":"ProtoBuf"},{"location":"references/mcap_handler_references/","text":"McapHandler Bases: Handler A handler class which writes log messages to MCAP files using ProtoBuf serialization. Source code in mcap_logger/mcap_handler.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class McapHandler ( logging . Handler ): \"\"\" A handler class which writes log messages to MCAP files using ProtoBuf serialization. \"\"\" def __init__ ( self , file : Path ) -> None : \"\"\" Open the specified file and use it as the stream for logging. If the file already exists, it will be overwritten. If the parent directory does not exist, it will be created. Args: file: The MCAP file to store the logs. \"\"\" super () . __init__ () self . _file : Path | TextIOWrapper = file self . writer : None | Writer = None self . _open () def emit ( self , record : logging . LogRecord ) -> None : \"\"\" Emit a record. The record will be emitted under the `/log` topic. Args: record: The record to emit into the log file. \"\"\" time_sec , time_ns = _split_time ( record . created ) log_message = Log ( timestamp = Timestamp ( nanos = time_ns , seconds = time_sec ), level = record . levelname , message = record . getMessage (), name = record . module , file = record . filename , line = record . lineno , ) self . writer . write_message ( topic = \"/log\" , message = log_message , log_time = int ( record . created * 1_000_000_000 ), publish_time = time . time_ns (), ) def close ( self ) -> None : \"\"\" Close the file. \"\"\" self . writer . finish () self . _file . close () super () . close () def _open ( self ) -> None : \"\"\" Open the log file and initialize the ProtoBuf writer. If the parent directory does not exist, it will be created. \"\"\" if self . writer is None : self . _file . parent . mkdir ( parents = True , exist_ok = True ) self . _file = self . _file . open ( \"wb\" ) self . writer = Writer ( self . _file ) __init__ ( file ) Open the specified file and use it as the stream for logging. If the file already exists, it will be overwritten. If the parent directory does not exist, it will be created. Parameters: Name Type Description Default file Path The MCAP file to store the logs. required Source code in mcap_logger/mcap_handler.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , file : Path ) -> None : \"\"\" Open the specified file and use it as the stream for logging. If the file already exists, it will be overwritten. If the parent directory does not exist, it will be created. Args: file: The MCAP file to store the logs. \"\"\" super () . __init__ () self . _file : Path | TextIOWrapper = file self . writer : None | Writer = None self . _open () close () Close the file. Source code in mcap_logger/mcap_handler.py 63 64 65 66 67 68 69 def close ( self ) -> None : \"\"\" Close the file. \"\"\" self . writer . finish () self . _file . close () super () . close () emit ( record ) Emit a record. The record will be emitted under the /log topic. Parameters: Name Type Description Default record LogRecord The record to emit into the log file. required Source code in mcap_logger/mcap_handler.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def emit ( self , record : logging . LogRecord ) -> None : \"\"\" Emit a record. The record will be emitted under the `/log` topic. Args: record: The record to emit into the log file. \"\"\" time_sec , time_ns = _split_time ( record . created ) log_message = Log ( timestamp = Timestamp ( nanos = time_ns , seconds = time_sec ), level = record . levelname , message = record . getMessage (), name = record . module , file = record . filename , line = record . lineno , ) self . writer . write_message ( topic = \"/log\" , message = log_message , log_time = int ( record . created * 1_000_000_000 ), publish_time = time . time_ns (), )","title":"MCAP Handler"},{"location":"references/mcap_handler_references/#mcap_logger.mcap_handler.McapHandler","text":"Bases: Handler A handler class which writes log messages to MCAP files using ProtoBuf serialization. Source code in mcap_logger/mcap_handler.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class McapHandler ( logging . Handler ): \"\"\" A handler class which writes log messages to MCAP files using ProtoBuf serialization. \"\"\" def __init__ ( self , file : Path ) -> None : \"\"\" Open the specified file and use it as the stream for logging. If the file already exists, it will be overwritten. If the parent directory does not exist, it will be created. Args: file: The MCAP file to store the logs. \"\"\" super () . __init__ () self . _file : Path | TextIOWrapper = file self . writer : None | Writer = None self . _open () def emit ( self , record : logging . LogRecord ) -> None : \"\"\" Emit a record. The record will be emitted under the `/log` topic. Args: record: The record to emit into the log file. \"\"\" time_sec , time_ns = _split_time ( record . created ) log_message = Log ( timestamp = Timestamp ( nanos = time_ns , seconds = time_sec ), level = record . levelname , message = record . getMessage (), name = record . module , file = record . filename , line = record . lineno , ) self . writer . write_message ( topic = \"/log\" , message = log_message , log_time = int ( record . created * 1_000_000_000 ), publish_time = time . time_ns (), ) def close ( self ) -> None : \"\"\" Close the file. \"\"\" self . writer . finish () self . _file . close () super () . close () def _open ( self ) -> None : \"\"\" Open the log file and initialize the ProtoBuf writer. If the parent directory does not exist, it will be created. \"\"\" if self . writer is None : self . _file . parent . mkdir ( parents = True , exist_ok = True ) self . _file = self . _file . open ( \"wb\" ) self . writer = Writer ( self . _file )","title":"McapHandler"},{"location":"references/mcap_handler_references/#mcap_logger.mcap_handler.McapHandler.__init__","text":"Open the specified file and use it as the stream for logging. If the file already exists, it will be overwritten. If the parent directory does not exist, it will be created. Parameters: Name Type Description Default file Path The MCAP file to store the logs. required Source code in mcap_logger/mcap_handler.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __init__ ( self , file : Path ) -> None : \"\"\" Open the specified file and use it as the stream for logging. If the file already exists, it will be overwritten. If the parent directory does not exist, it will be created. Args: file: The MCAP file to store the logs. \"\"\" super () . __init__ () self . _file : Path | TextIOWrapper = file self . writer : None | Writer = None self . _open ()","title":"__init__"},{"location":"references/mcap_handler_references/#mcap_logger.mcap_handler.McapHandler.close","text":"Close the file. Source code in mcap_logger/mcap_handler.py 63 64 65 66 67 68 69 def close ( self ) -> None : \"\"\" Close the file. \"\"\" self . writer . finish () self . _file . close () super () . close ()","title":"close"},{"location":"references/mcap_handler_references/#mcap_logger.mcap_handler.McapHandler.emit","text":"Emit a record. The record will be emitted under the /log topic. Parameters: Name Type Description Default record LogRecord The record to emit into the log file. required Source code in mcap_logger/mcap_handler.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def emit ( self , record : logging . LogRecord ) -> None : \"\"\" Emit a record. The record will be emitted under the `/log` topic. Args: record: The record to emit into the log file. \"\"\" time_sec , time_ns = _split_time ( record . created ) log_message = Log ( timestamp = Timestamp ( nanos = time_ns , seconds = time_sec ), level = record . levelname , message = record . getMessage (), name = record . module , file = record . filename , line = record . lineno , ) self . writer . write_message ( topic = \"/log\" , message = log_message , log_time = int ( record . created * 1_000_000_000 ), publish_time = time . time_ns (), )","title":"emit"},{"location":"references/topic_logger_references/","text":"Topic Source code in mcap_logger/topic_logger.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Topic : def __init__ ( self , name : str , writer : Writer , ) -> None : \"\"\" Initializes Topic entity. Args: name: The name of the topic. writer: The MCap file writer with protobuf serialization. \"\"\" self . _name = name self . _writer = writer def write ( self , message : Any ) -> None : # noqa: ANN401 \"\"\" Writes topic with protobuf message to the log file. Args: message: The protobuf message. \"\"\" if self . _writer is not None : timestamp = time . time_ns () self . _writer . write_message ( topic = self . _name , message = message , log_time = timestamp , publish_time = timestamp , ) __init__ ( name , writer ) Initializes Topic entity. Parameters: Name Type Description Default name str The name of the topic. required writer Writer The MCap file writer with protobuf serialization. required Source code in mcap_logger/topic_logger.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , name : str , writer : Writer , ) -> None : \"\"\" Initializes Topic entity. Args: name: The name of the topic. writer: The MCap file writer with protobuf serialization. \"\"\" self . _name = name self . _writer = writer write ( message ) Writes topic with protobuf message to the log file. Parameters: Name Type Description Default message Any The protobuf message. required Source code in mcap_logger/topic_logger.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def write ( self , message : Any ) -> None : # noqa: ANN401 \"\"\" Writes topic with protobuf message to the log file. Args: message: The protobuf message. \"\"\" if self . _writer is not None : timestamp = time . time_ns () self . _writer . write_message ( topic = self . _name , message = message , log_time = timestamp , publish_time = timestamp , ) TopicLogger A logger class which manages writing data logs to MCAP files. Not related to logging.Logger. Source code in mcap_logger/topic_logger.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class TopicLogger : \"\"\" A logger class which manages writing data logs to MCAP files. Not related to logging.Logger. \"\"\" def __init__ ( self , logger_name : str ) -> None : \"\"\" Fetch ProtoBuf writer from the logger's McapHandler. If the logger doesn't have McapHandler, the data logs won't be written. Args: logger_name: The name of the logger to get the McapHandler from. \"\"\" self . _writer = self . _fetch_writer_from_logger ( logger_name ) def topic ( self , topic_name : str ) -> Topic : \"\"\" Create a topic for data logging. Args: topic_name: The name of the topic. Returns: The created topic. \"\"\" return Topic ( topic_name , writer = self . _writer ) @staticmethod def _fetch_writer_from_logger ( logger_name : str ) -> Writer | None : \"\"\" Fetch ProtoBuf writer from the logger's McapHandler. Returns None if the logger doesn't have McapHandler. Args: logger_name: The name of the logger to get the McapHandler from. Returns: The logger's ProtoBuf writer. \"\"\" for handler in logging . getLogger ( logger_name ) . handlers : if isinstance ( handler , McapHandler ): return handler . writer return None __init__ ( logger_name ) Fetch ProtoBuf writer from the logger's McapHandler. If the logger doesn't have McapHandler, the data logs won't be written. Parameters: Name Type Description Default logger_name str The name of the logger to get the McapHandler from. required Source code in mcap_logger/topic_logger.py 50 51 52 53 54 55 56 57 58 59 def __init__ ( self , logger_name : str ) -> None : \"\"\" Fetch ProtoBuf writer from the logger's McapHandler. If the logger doesn't have McapHandler, the data logs won't be written. Args: logger_name: The name of the logger to get the McapHandler from. \"\"\" self . _writer = self . _fetch_writer_from_logger ( logger_name ) topic ( topic_name ) Create a topic for data logging. Parameters: Name Type Description Default topic_name str The name of the topic. required Returns: Type Description Topic The created topic. Source code in mcap_logger/topic_logger.py 61 62 63 64 65 66 67 68 69 70 71 def topic ( self , topic_name : str ) -> Topic : \"\"\" Create a topic for data logging. Args: topic_name: The name of the topic. Returns: The created topic. \"\"\" return Topic ( topic_name , writer = self . _writer )","title":"Topic Logger"},{"location":"references/topic_logger_references/#mcap_logger.topic_logger.Topic","text":"Source code in mcap_logger/topic_logger.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Topic : def __init__ ( self , name : str , writer : Writer , ) -> None : \"\"\" Initializes Topic entity. Args: name: The name of the topic. writer: The MCap file writer with protobuf serialization. \"\"\" self . _name = name self . _writer = writer def write ( self , message : Any ) -> None : # noqa: ANN401 \"\"\" Writes topic with protobuf message to the log file. Args: message: The protobuf message. \"\"\" if self . _writer is not None : timestamp = time . time_ns () self . _writer . write_message ( topic = self . _name , message = message , log_time = timestamp , publish_time = timestamp , )","title":"Topic"},{"location":"references/topic_logger_references/#mcap_logger.topic_logger.Topic.__init__","text":"Initializes Topic entity. Parameters: Name Type Description Default name str The name of the topic. required writer Writer The MCap file writer with protobuf serialization. required Source code in mcap_logger/topic_logger.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , name : str , writer : Writer , ) -> None : \"\"\" Initializes Topic entity. Args: name: The name of the topic. writer: The MCap file writer with protobuf serialization. \"\"\" self . _name = name self . _writer = writer","title":"__init__"},{"location":"references/topic_logger_references/#mcap_logger.topic_logger.Topic.write","text":"Writes topic with protobuf message to the log file. Parameters: Name Type Description Default message Any The protobuf message. required Source code in mcap_logger/topic_logger.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def write ( self , message : Any ) -> None : # noqa: ANN401 \"\"\" Writes topic with protobuf message to the log file. Args: message: The protobuf message. \"\"\" if self . _writer is not None : timestamp = time . time_ns () self . _writer . write_message ( topic = self . _name , message = message , log_time = timestamp , publish_time = timestamp , )","title":"write"},{"location":"references/topic_logger_references/#mcap_logger.topic_logger.TopicLogger","text":"A logger class which manages writing data logs to MCAP files. Not related to logging.Logger. Source code in mcap_logger/topic_logger.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class TopicLogger : \"\"\" A logger class which manages writing data logs to MCAP files. Not related to logging.Logger. \"\"\" def __init__ ( self , logger_name : str ) -> None : \"\"\" Fetch ProtoBuf writer from the logger's McapHandler. If the logger doesn't have McapHandler, the data logs won't be written. Args: logger_name: The name of the logger to get the McapHandler from. \"\"\" self . _writer = self . _fetch_writer_from_logger ( logger_name ) def topic ( self , topic_name : str ) -> Topic : \"\"\" Create a topic for data logging. Args: topic_name: The name of the topic. Returns: The created topic. \"\"\" return Topic ( topic_name , writer = self . _writer ) @staticmethod def _fetch_writer_from_logger ( logger_name : str ) -> Writer | None : \"\"\" Fetch ProtoBuf writer from the logger's McapHandler. Returns None if the logger doesn't have McapHandler. Args: logger_name: The name of the logger to get the McapHandler from. Returns: The logger's ProtoBuf writer. \"\"\" for handler in logging . getLogger ( logger_name ) . handlers : if isinstance ( handler , McapHandler ): return handler . writer return None","title":"TopicLogger"},{"location":"references/topic_logger_references/#mcap_logger.topic_logger.TopicLogger.__init__","text":"Fetch ProtoBuf writer from the logger's McapHandler. If the logger doesn't have McapHandler, the data logs won't be written. Parameters: Name Type Description Default logger_name str The name of the logger to get the McapHandler from. required Source code in mcap_logger/topic_logger.py 50 51 52 53 54 55 56 57 58 59 def __init__ ( self , logger_name : str ) -> None : \"\"\" Fetch ProtoBuf writer from the logger's McapHandler. If the logger doesn't have McapHandler, the data logs won't be written. Args: logger_name: The name of the logger to get the McapHandler from. \"\"\" self . _writer = self . _fetch_writer_from_logger ( logger_name )","title":"__init__"},{"location":"references/topic_logger_references/#mcap_logger.topic_logger.TopicLogger.topic","text":"Create a topic for data logging. Parameters: Name Type Description Default topic_name str The name of the topic. required Returns: Type Description Topic The created topic. Source code in mcap_logger/topic_logger.py 61 62 63 64 65 66 67 68 69 70 71 def topic ( self , topic_name : str ) -> Topic : \"\"\" Create a topic for data logging. Args: topic_name: The name of the topic. Returns: The created topic. \"\"\" return Topic ( topic_name , writer = self . _writer )","title":"topic"},{"location":"tutorials/create-you-first-log/","text":"Create Our First Log (new version) In this tutorial, we will log a message into a hello.mcap file. Setup our tutorial project In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We can run our \"Hello World\" program with the following command: uv run hello.py This should produce the following output on your console: Hello from mcap-logger-tutorial! We will use this \"Hello World\" program as a base for our tutorial. Create our first log First, let's import the logging package of Python and the McapHandler class into the hello.py script. After we did the import, we will create our Logger entity with the getLogger function. We will call the logger mcap_logger . hello.py 1 2 3 4 5 6 7 import logging from mcap_logger.mcap_handler import McapHandler def main (): logger = logging . getLogger ( \"mcap_logger\" ) print ( \"Hello from mcap-logger-tutorial!\" ) Then we will define the log file we want to create. To do that, we need to import Path and specify the log file's name and path. In this case the log file will be called hello.mcap and we will place it in the project's directory. After this, we can create our mcap log handler by initializing it with the path of the log file. Info If the parent directory of the defined log doesn't exist, the it will be created. hello.py 1 2 3 4 5 6 7 8 9 10 11 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) print ( \"Hello from mcap-logger-tutorial!\" ) When we created our handler then we have to add it to the logger. This means that when the logger logs a message then it will hand it to our MCAP handler, which will put this into our log file. We will set the level of logging to be DEBUG level both for the logger and for the handler. This basically means that all log messages will be logged. We will remove the original print statement and replace it with an info level log call. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main () Create the log file Now that we made modification to the hello.py , we can run our example again and see the result. uv run hello.py Note There will be no console logs, because we only added and McapHandler to the logger. Notice that we have a new file in our project directory called hello.mcap . This file is serialized with Protobuf , so we can not open it with a text editor and look at the content of it. To do that we will use Foxglove Studio . Open our log file Open Foxglove Studio and use the Open local file... command to open our hello.mcap log file. Our log messages is using Foxglove's Log schema , and we can visualise it with a Log panel . We can add a panel following this guide , and after that we need to configure it to use the /log topic. log panel settings After this we should see our info message on the log panel. log panel output And Voil\u00e0! We made our first log with mcap-logger . Filtering logs Notice that in Foxglove Studio, you can filter the logs by their level in the log panel.","title":"Create Your First Log"},{"location":"tutorials/create-you-first-log/#create-our-first-log-new-version","text":"In this tutorial, we will log a message into a hello.mcap file.","title":"Create Our First Log (new version)"},{"location":"tutorials/create-you-first-log/#setup-our-tutorial-project","text":"In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We can run our \"Hello World\" program with the following command: uv run hello.py This should produce the following output on your console: Hello from mcap-logger-tutorial! We will use this \"Hello World\" program as a base for our tutorial.","title":"Setup our tutorial project"},{"location":"tutorials/create-you-first-log/#create-our-first-log","text":"First, let's import the logging package of Python and the McapHandler class into the hello.py script. After we did the import, we will create our Logger entity with the getLogger function. We will call the logger mcap_logger . hello.py 1 2 3 4 5 6 7 import logging from mcap_logger.mcap_handler import McapHandler def main (): logger = logging . getLogger ( \"mcap_logger\" ) print ( \"Hello from mcap-logger-tutorial!\" ) Then we will define the log file we want to create. To do that, we need to import Path and specify the log file's name and path. In this case the log file will be called hello.mcap and we will place it in the project's directory. After this, we can create our mcap log handler by initializing it with the path of the log file. Info If the parent directory of the defined log doesn't exist, the it will be created. hello.py 1 2 3 4 5 6 7 8 9 10 11 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) print ( \"Hello from mcap-logger-tutorial!\" ) When we created our handler then we have to add it to the logger. This means that when the logger logs a message then it will hand it to our MCAP handler, which will put this into our log file. We will set the level of logging to be DEBUG level both for the logger and for the handler. This basically means that all log messages will be logged. We will remove the original print statement and replace it with an info level log call. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main ()","title":"Create our first log"},{"location":"tutorials/create-you-first-log/#create-the-log-file","text":"Now that we made modification to the hello.py , we can run our example again and see the result. uv run hello.py Note There will be no console logs, because we only added and McapHandler to the logger. Notice that we have a new file in our project directory called hello.mcap . This file is serialized with Protobuf , so we can not open it with a text editor and look at the content of it. To do that we will use Foxglove Studio .","title":"Create the log file"},{"location":"tutorials/create-you-first-log/#open-our-log-file","text":"Open Foxglove Studio and use the Open local file... command to open our hello.mcap log file. Our log messages is using Foxglove's Log schema , and we can visualise it with a Log panel . We can add a panel following this guide , and after that we need to configure it to use the /log topic. log panel settings After this we should see our info message on the log panel. log panel output And Voil\u00e0! We made our first log with mcap-logger . Filtering logs Notice that in Foxglove Studio, you can filter the logs by their level in the log panel.","title":"Open our log file"},{"location":"tutorials/installation/","text":"Installation The MCAP Logger is published as a Python package and can be installed with pip , ideally using a virtual environment . We can also use a package and project manager like Poetry or uv to handle the environment for us. pip Poetry uv pip install mcap-logger Poetry add mcap-logger uv add mcap-logger Python package and project managers The best is to use a Python package and project manager, this would make the managing of packages and virtual environments way easier. Here is how to install Poetry or uv and setup a project.","title":"Installation"},{"location":"tutorials/installation/#installation","text":"The MCAP Logger is published as a Python package and can be installed with pip , ideally using a virtual environment . We can also use a package and project manager like Poetry or uv to handle the environment for us. pip Poetry uv pip install mcap-logger Poetry add mcap-logger uv add mcap-logger Python package and project managers The best is to use a Python package and project manager, this would make the managing of packages and virtual environments way easier. Here is how to install Poetry or uv and setup a project.","title":"Installation"},{"location":"tutorials/logging-sensor-data/","text":"Logging Sensor Data (new version) In this tutorial, we will log sensor data from a simulated thermostat into thermostat.mcap file. Setup our tutorial project In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We will change the hello.py to thermostat.py shown below. thermostat.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 80 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"thermostat.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main () Simulated Thermostat The thermostat readings comes from the THERMOSTAT_DATA dictionary. Installing ProtoBuf Protocol Buffers (a.k.a ProtoBuf) are Google's language-neutral mechanism for serializing structured data. It is used as the serialisation protocol for mcap-logger . We need to install the ProtoBuf compiler called protoc in order to work with ProtoBuf. Download the package and follow the instructions in the README . We can confirm the installation with running the protoc --version command in the terminal. Creating our protocol format To specify our protocol format for the sensor data, we need to create a thermostat_data.proto file in our project directory. The definitions in a .proto file are simple: we add a message for each data structure we want to serialise, then specify a name and a type for each field in the message. Our thermostat has temperature and humidity readings, so our .proto file will look like the following. thermostat_data.proto syntax = \"proto3\" ; message ThermostatData { int32 temperature = 1 ; int32 humidity = 2 ; } ProtoBuf Syntax This is the Language Guide for proto3. Protobuf Python tutorial Compiling our protocol buffers After we defined our protocol, we need to generate the Python classes to read and write messages. To do that we will run the protoc compiler on our .proto file. protoc --python_out = . thermostat_data.proto This will generate a new Python file called thermostat_data_pb2.py in our project directory. Our project directory should look something like this by now: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 thermostat_data.proto \u2514\u2500\u2500 thermostat_data_pb2.py Importing ProtoBuf To create a thermostat data in our hello.py script, we need to import the ThermostatData class from the generated thermostat_data_pb2.py . thermostat.py from thermostat_data_pb2 import ThermostatData Warning In some cases the import can confuse the linter and generate \"Cannot find reference\" errors. However the interpreter will work with this import. This can be resolved if you add plugins to your IDE for ProtoBuf support. For example, now we can define our thermostat data as the following: thermostat_data = SensorData ( temperature = 20 , humidity = 65 ) Log the sensor data After our first info log message, we will create a TopicLogger instance as following: thermostat.py topic_logger = TopicLogger ( \"mcap_logger\" ) When the TopicLogger is initialized with a logger name, it checks if the logger has a McapHandler and if yes then it will get the reference of its ProtoBuf writer. This means that the TopicLogger will use the same file writer to log data as the log message logging. Next, we will create a for loop with sleeping for 0.5 second to simulate the reading out of a thermostat sensor. thermostat.py for data in THERMOSTAT_DATA : time . sleep ( 0.5 ) temperature = data [ \"temp\" ] humidity = data [ \"humid\" ] thermostat_data = ThermostatData ( temperature = temperature , humidity = humidity ) To log the thermostat_data , we need to specify a Topic for our log. In this case, we will call it /thermostat topic, and we will call the TopicLogger 's topic function to create it. Topics have a write() function that will log the data in its argument into the log file. So with calling topic_logger.topic(<topic_name>).write(<data>) we can log any ProtoBuf data into our log file. thermostat.py topic_logger . topic ( '/thermostat' ) . write ( thermostat_data ) To make it a bit more interesting, let's log a warning message when the temperature goes below zero! Now our thermostat.py script should look like this: thermostat.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import logging import time from pathlib import Path from examples.thermostat_data_pb2 import ThermostatData from mcap_logger.mcap_handler import McapHandler from mcap_logger.topic_logger import TopicLogger THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 80 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"thermostat.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) topic_logger = TopicLogger ( \"mcap_logger\" ) for data in THERMOSTAT_DATA : time . sleep ( 0.5 ) temperature = data [ \"temp\" ] humidity = data [ \"humid\" ] thermostat_data = ThermostatData ( temperature = temperature , humidity = humidity ) topic_logger . topic ( \"/thermostat\" ) . write ( thermostat_data ) if temperature < 0 : logger . warning ( \"Temperature is below zero!\" ) if __name__ == \"__main__\" : main () Running the thermostat After finishing the thermostat.py script, we can run it to generate the log file. uv run thermostat.py When the script is finished running, we should have the generated thermostat.mcap in our project directory. Opening our log file Open Foxglove Studio and use the Open local file... command to open our thermostat.mcap log file. We need to change the layout so that we have a Log panel and a Plot panel. In the settings we will configure the Log panel to use the /log topic, and for the Plot panel we will add two Series : one for the /thermostat.humidity and one for the /thermostat.temperature . log panel settings plot panel settings After this, we can play back the log and see the visualisation of the thermostat data alongside with the log messages. thermostat log in Foxglove Now you know how to make full use of the mcap-logger package.","title":"Logging Sensor Data"},{"location":"tutorials/logging-sensor-data/#logging-sensor-data-new-version","text":"In this tutorial, we will log sensor data from a simulated thermostat into thermostat.mcap file.","title":"Logging Sensor Data (new version)"},{"location":"tutorials/logging-sensor-data/#setup-our-tutorial-project","text":"In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We will change the hello.py to thermostat.py shown below. thermostat.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 80 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"thermostat.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main () Simulated Thermostat The thermostat readings comes from the THERMOSTAT_DATA dictionary.","title":"Setup our tutorial project"},{"location":"tutorials/logging-sensor-data/#installing-protobuf","text":"Protocol Buffers (a.k.a ProtoBuf) are Google's language-neutral mechanism for serializing structured data. It is used as the serialisation protocol for mcap-logger . We need to install the ProtoBuf compiler called protoc in order to work with ProtoBuf. Download the package and follow the instructions in the README . We can confirm the installation with running the protoc --version command in the terminal.","title":"Installing ProtoBuf"},{"location":"tutorials/logging-sensor-data/#creating-our-protocol-format","text":"To specify our protocol format for the sensor data, we need to create a thermostat_data.proto file in our project directory. The definitions in a .proto file are simple: we add a message for each data structure we want to serialise, then specify a name and a type for each field in the message. Our thermostat has temperature and humidity readings, so our .proto file will look like the following. thermostat_data.proto syntax = \"proto3\" ; message ThermostatData { int32 temperature = 1 ; int32 humidity = 2 ; } ProtoBuf Syntax This is the Language Guide for proto3. Protobuf Python tutorial","title":"Creating our protocol format"},{"location":"tutorials/logging-sensor-data/#compiling-our-protocol-buffers","text":"After we defined our protocol, we need to generate the Python classes to read and write messages. To do that we will run the protoc compiler on our .proto file. protoc --python_out = . thermostat_data.proto This will generate a new Python file called thermostat_data_pb2.py in our project directory. Our project directory should look something like this by now: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 thermostat_data.proto \u2514\u2500\u2500 thermostat_data_pb2.py","title":"Compiling our protocol buffers"},{"location":"tutorials/logging-sensor-data/#importing-protobuf","text":"To create a thermostat data in our hello.py script, we need to import the ThermostatData class from the generated thermostat_data_pb2.py . thermostat.py from thermostat_data_pb2 import ThermostatData Warning In some cases the import can confuse the linter and generate \"Cannot find reference\" errors. However the interpreter will work with this import. This can be resolved if you add plugins to your IDE for ProtoBuf support. For example, now we can define our thermostat data as the following: thermostat_data = SensorData ( temperature = 20 , humidity = 65 )","title":"Importing ProtoBuf"},{"location":"tutorials/logging-sensor-data/#log-the-sensor-data","text":"After our first info log message, we will create a TopicLogger instance as following: thermostat.py topic_logger = TopicLogger ( \"mcap_logger\" ) When the TopicLogger is initialized with a logger name, it checks if the logger has a McapHandler and if yes then it will get the reference of its ProtoBuf writer. This means that the TopicLogger will use the same file writer to log data as the log message logging. Next, we will create a for loop with sleeping for 0.5 second to simulate the reading out of a thermostat sensor. thermostat.py for data in THERMOSTAT_DATA : time . sleep ( 0.5 ) temperature = data [ \"temp\" ] humidity = data [ \"humid\" ] thermostat_data = ThermostatData ( temperature = temperature , humidity = humidity ) To log the thermostat_data , we need to specify a Topic for our log. In this case, we will call it /thermostat topic, and we will call the TopicLogger 's topic function to create it. Topics have a write() function that will log the data in its argument into the log file. So with calling topic_logger.topic(<topic_name>).write(<data>) we can log any ProtoBuf data into our log file. thermostat.py topic_logger . topic ( '/thermostat' ) . write ( thermostat_data ) To make it a bit more interesting, let's log a warning message when the temperature goes below zero! Now our thermostat.py script should look like this: thermostat.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import logging import time from pathlib import Path from examples.thermostat_data_pb2 import ThermostatData from mcap_logger.mcap_handler import McapHandler from mcap_logger.topic_logger import TopicLogger THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 80 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def main (): logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"thermostat.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) topic_logger = TopicLogger ( \"mcap_logger\" ) for data in THERMOSTAT_DATA : time . sleep ( 0.5 ) temperature = data [ \"temp\" ] humidity = data [ \"humid\" ] thermostat_data = ThermostatData ( temperature = temperature , humidity = humidity ) topic_logger . topic ( \"/thermostat\" ) . write ( thermostat_data ) if temperature < 0 : logger . warning ( \"Temperature is below zero!\" ) if __name__ == \"__main__\" : main ()","title":"Log the sensor data"},{"location":"tutorials/logging-sensor-data/#running-the-thermostat","text":"After finishing the thermostat.py script, we can run it to generate the log file. uv run thermostat.py When the script is finished running, we should have the generated thermostat.mcap in our project directory.","title":"Running the thermostat"},{"location":"tutorials/logging-sensor-data/#opening-our-log-file","text":"Open Foxglove Studio and use the Open local file... command to open our thermostat.mcap log file. We need to change the layout so that we have a Log panel and a Plot panel. In the settings we will configure the Log panel to use the /log topic, and for the Plot panel we will add two Series : one for the /thermostat.humidity and one for the /thermostat.temperature . log panel settings plot panel settings After this, we can play back the log and see the visualisation of the thermostat data alongside with the log messages. thermostat log in Foxglove Now you know how to make full use of the mcap-logger package.","title":"Opening our log file"},{"location":"tutorials/use-console-stream-with-mcap-logging/","text":"Use Console Stream with MCAP Logging In this tutorial, we will look into how we can combine different log handlers to have console output and MCAP log at the same time. Setup our tutorial project In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We will change the hello.py as shown below. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): # noqa: ANN201 logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main () Configure console logging We can see that in our code, we create a logger instance, and we add our McapHandler to it as a handler. A Python logger can have multiple handlers. It can be beneficial for an application to log all messages of all severities to a file while simultaneously logging warning or above to the console. To set this up, we have to add a StreamHandler to our logger instance as follows. stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( stream_handler ) Note, that we can set the logging level separately from other handlers and from the logger. In this case, becasue the level of the logger is DEBUG , it will forward all log messages to the handlers. The mcap_handler has also DEBUG level, so it will log every messages to the log file. The stream_handler has WARNING log level, which means that it will only print messages that are WARNING or prior to WARNING . Logging Flow Here you can check the flowdiagram of the logging. We can add a warning message to our hello.py script to see the behaviour described above. After the modifications our hello.py script should look like this. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): # noqa: ANN201 logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) logger . warning ( \"This is a warning\" ) if __name__ == \"__main__\" : main () Running the script uv run hello.py When we run the command above, we should see that the warning message is printed on our console (and the info message is not), and also that we have a hello.mcap file in our folder that contains both the warning message and the info message. Code structuring Our code is functional, however it is really verbose and suppress the essential parts of the main function (the two log messages \ud83d\ude04). We can move the technical details of the logger to its own function, so that all the logger configuration can live in one place. We should also move the logger variable out to the global scope so that any function in the script can access it. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) return logger log_file = Path ( \"hello.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): # noqa: ANN201 log . info ( \"Hello from mcap-logger-tutorial!\" ) log . warning ( \"This is a warning\" ) if __name__ == \"__main__\" : main () With this, we have a simple example that how we can configure a logger with both console and MCAP logging. Configuring Logging To learn about more advanced logging configuration, please check out the Logging HOWTO - Configuring Logging section","title":"Use Console Stream With MCAP Logging"},{"location":"tutorials/use-console-stream-with-mcap-logging/#use-console-stream-with-mcap-logging","text":"In this tutorial, we will look into how we can combine different log handlers to have console output and MCAP log at the same time.","title":"Use Console Stream with MCAP Logging"},{"location":"tutorials/use-console-stream-with-mcap-logging/#setup-our-tutorial-project","text":"In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We will change the hello.py as shown below. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): # noqa: ANN201 logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main ()","title":"Setup our tutorial project"},{"location":"tutorials/use-console-stream-with-mcap-logging/#configure-console-logging","text":"We can see that in our code, we create a logger instance, and we add our McapHandler to it as a handler. A Python logger can have multiple handlers. It can be beneficial for an application to log all messages of all severities to a file while simultaneously logging warning or above to the console. To set this up, we have to add a StreamHandler to our logger instance as follows. stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( stream_handler ) Note, that we can set the logging level separately from other handlers and from the logger. In this case, becasue the level of the logger is DEBUG , it will forward all log messages to the handlers. The mcap_handler has also DEBUG level, so it will log every messages to the log file. The stream_handler has WARNING log level, which means that it will only print messages that are WARNING or prior to WARNING . Logging Flow Here you can check the flowdiagram of the logging. We can add a warning message to our hello.py script to see the behaviour described above. After the modifications our hello.py script should look like this. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def main (): # noqa: ANN201 logger = logging . getLogger ( \"mcap_logger\" ) log_file = Path ( \"hello.mcap\" ) mcap_handler = McapHandler ( log_file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) logger . info ( \"Hello from mcap-logger-tutorial!\" ) logger . warning ( \"This is a warning\" ) if __name__ == \"__main__\" : main ()","title":"Configure console logging"},{"location":"tutorials/use-console-stream-with-mcap-logging/#running-the-script","text":"uv run hello.py When we run the command above, we should see that the warning message is printed on our console (and the info message is not), and also that we have a hello.mcap file in our folder that contains both the warning message and the info message.","title":"Running the script"},{"location":"tutorials/use-console-stream-with-mcap-logging/#code-structuring","text":"Our code is functional, however it is really verbose and suppress the essential parts of the main function (the two log messages \ud83d\ude04). We can move the technical details of the logger to its own function, so that all the logger configuration can live in one place. We should also move the logger variable out to the global scope so that any function in the script can access it. hello.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) return logger log_file = Path ( \"hello.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): # noqa: ANN201 log . info ( \"Hello from mcap-logger-tutorial!\" ) log . warning ( \"This is a warning\" ) if __name__ == \"__main__\" : main () With this, we have a simple example that how we can configure a logger with both console and MCAP logging. Configuring Logging To learn about more advanced logging configuration, please check out the Logging HOWTO - Configuring Logging section","title":"Code structuring"},{"location":"tutorials/using-mcap-logging-in-libraries/","text":"from logging import NullHandlerfrom examples.library import thermostat_monitor Using MCAP Logging in Libraries This tutorial will show you how the logging should be handled in libraries. Setup our tutorial project In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We will replace the hello.py script with application.py adn library.py . application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): # noqa: ANN201 log . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main () The application.py is just our examples/hello.py example, and it only logs a log message. library.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 110 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def get_thermostat_data (): for data in THERMOSTAT_DATA : humidity = data [ \"humid\" ] if humidity < 0 or humidity > 100 : print ( \"invalid humidity!\" ) else : yield data if __name__ == \"__main__\" : for data in get_thermostat_data (): print ( data ) The library.py is a modification of our examples/thermostat.py script. In this version we have the get_thermostat_data function, that yields back the data from the THERMOSTAT_DATA array, when the data is valid. If the humidity is out of boundaries then it will print a message to the console. We can run this library example with uv run library.py and see the printed out data and the error message. { 'temp' : 10 , 'humid' : 70 } { 'temp' : 5 , 'humid' : 75 } { 'temp' : 2 , 'humid' : 78 } invalid humidity! { 'temp' : 3 , 'humid' : 79 } Import our library into our application Now, we will import this simple library into our application, and call its get_thermostat_data function in a for-loop. We will also simulate the time passing with a time.sleep call. After the log.info call we should add the following code. application.py for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"fetching data from thermostat\" ) When we run this code that we can see the warning message on the console and that the .mcap log file was created with all the log messages we created except the library's logs. However, using print statements should be avoided, so we have to create a logger for our library. Creating logger for our library Info Python's Logging HOWTO guide has a nice documentation on how to configure logging for a library The application developer knows their target audience and what handlers are most appropriate for their application. So we have to give the application full control over how the library does the logging. Our library should create a logger with a unique and easily identifiable name, and we should not add any handlers to it other than NullHandler . A NullHandler is a 'do nothing' handler, and we can use it to assure that our logger won't fall back to the LastResort handler. Loggers are hierarchical, and they inherit configurations from the top-level logger. If all logging by a library foo is done using loggers with names matching foo.x , foo.y , etc. then we can configure the NullHandler only for the top-level logger of the library like the following code. import logging logging . getLogger ( 'foo' ) . addHandler ( logging . NullHandler ()) In our case, we have only one library script, so we will configure our logger in it. In the library.py we import the logging package and create our logger instance called by library . Then we add the NullHandler to the library's logger. Tip Use a logger with a unique and easily identifiable name, such as the __name__ for your library\u2019s top-level package or module. library.py import logging log = logging . getLogger ( \"library\" ) log . addHandler ( logging . NullHandler ()) Then we should replace the print statements with logger calls. library.py log . warning ( \"invalid humidity!\" ) and library.py log . info ( data ) If we run now our library standalone, we can see that no output is generated on the console. This is because all the logs are handed over to the NullHandler which discards them. We can change this behavior for the standalone run if we change the configuration of the logger when we only run the library script. The code belows shows how our library script should look like after the changes. library.py import logging log = logging . getLogger ( \"library\" ) log . addHandler ( logging . NullHandler ()) THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 110 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def get_thermostat_data (): for data in THERMOSTAT_DATA : humidity = data [ \"humid\" ] if humidity < 0 or humidity > 100 : log . warning ( \"invalid humidity!\" ) else : yield data if __name__ == \"__main__\" : stream_handler = logging . StreamHandler () stream_handler . setLevel ( logging . DEBUG ) logging . getLogger ( \"library\" ) . addHandler ( stream_handler ) logging . getLogger ( \"library\" ) . setLevel ( logging . DEBUG ) for data in get_thermostat_data (): log . info ( data ) Note Loggers are singletons , this means the only one instance of a logger with a given name exists. When you call the getLogger function with an existing name, then it will return that singleton. Configure the library logger from application Now, that we have library with logging, we have to configure its logger from our application if we want to use it. We have many possibilities on how we could configure the logger, for now, let's say that we want the library to use the same level of logging as the application logger, and it should also log to the same file. We will add this configuration step into our get_logger function, where we defined the StreamHandler and McapHandler for our application logging. We just have to add the same handler to the library's logger as follows. application.py def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger When we run the application now, we should see all the log messages on the console and in the .mcap file. applciation.mcap [ INFO ][ 12 :40:34.683 PM CET ][ application ] : Hello from mcap-logger-tutorial! [ DEBUG ][ 12 :40:35.184 PM CET ][ application ] : fetching data from thermostat [ DEBUG ][ 12 :40:35.684 PM CET ][ application ] : fetching data from thermostat [ DEBUG ][ 12 :40:36.184 PM CET ][ application ] : fetching data from thermostat [ WARN ][ 12 :40:36.184 PM CET ][ library ] : invalid humidity! [ DEBUG ][ 12 :40:36.684 PM CET ][ application ] : fetching data from thermostat As you can see, this approach gives us plenty of opportunity to fine tune the logging behaviour of our library from our application. We configure the library logger to only log higher severity message on the console and the mcap file. Or log into a different mcap file or not to do file logging at all. The choice is in the application developer to figure out what makes sense for them. Take care to document how your library uses logging - for example, the names of loggers used. Adding data logging Following the rule of thumb for how to configure library logging, we can see that we should not let our library populate our system with data log files whenever we run it. As before this should be up to the application developer. To achieve this we should follow the following rules: Functions that don't run as a process, must not create topic logs. Functions that run as a process, should create topic logs. ProtoBuf file should be provided for topic logs. Let's see two scenarios to see the difference. Data logging from application Given that we have the following aplication.py script. application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import logging import time from pathlib import Path from examples.library import get_thermostat_data from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): log . info ( \"Hello from mcap-logger-tutorial!\" ) for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"fetching data from thermostat\" ) if __name__ == \"__main__\" : main () Let's say that we want to log the thermostat data from our application to the mcap file. In this case, we should import the PotoBuf script of the thermostat data into our applicaton.py script and call the TopicLogger from there. application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import logging import time from pathlib import Path from examples.library import get_thermostat_data from examples.thermostat_data_pb2 import ThermostatData from mcap_logger.mcap_handler import McapHandler from mcap_logger.topic_logger import TopicLogger def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): log . info ( \"Hello from mcap-logger-tutorial!\" ) for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"fetching data from thermostat\" ) data_log = ThermostatData ( temperature = data [ \"temp\" ], humidity = data [ \"humid\" ]) TopicLogger ( \"mcap_logger\" ) . topic ( \"/thermostat\" ) . write ( data_log ) if __name__ == \"__main__\" : main () In this scenario, the library is only used to get the data from our \"sensor\", and because of this it is the applications choice and responsibility to log it. Data logging from library It is possible that the library has functions that can be imported and run as a process by other scripts. For example, lets add a thermostat_monitor to our library, that fetches the data from the thermostat, logs the data and creates a warning log if the temperature is below zero. library.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import logging import time from examples.thermostat_data_pb2 import ThermostatData from mcap_logger.topic_logger import TopicLogger log = logging . getLogger ( \"library\" ) log . addHandler ( logging . NullHandler ()) THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 789 }, { \"temp\" : - 1 , \"humid\" : 80 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def get_thermostat_data (): for data in THERMOSTAT_DATA : humidity = data [ \"humid\" ] if humidity < 0 or humidity > 100 : log . warning ( \"invalid humidity!\" ) else : yield data def thermostat_monitor (): for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"got data from thermostat\" ) if data [ \"temp\" ] < 0 : log . warning ( \"temperature is below zero\" ) data_log = ThermostatData ( temperature = data [ \"temp\" ], humidity = data [ \"humid\" ]) TopicLogger ( \"library\" ) . topic ( \"/thermostat\" ) . write ( data_log ) if __name__ == \"__main__\" : stream_handler = logging . StreamHandler () stream_handler . setLevel ( logging . DEBUG ) logging . getLogger ( \"library\" ) . addHandler ( stream_handler ) logging . getLogger ( \"library\" ) . setLevel ( logging . DEBUG ) thermostat_monitor () The monitor function can be imported by another script and run it as a process until all the data is fetched. In this case, the monitor function does the logging, but only if the given logger name has an McapHandler added to it. If no, then the topic log will be discarded. From the application side, we will configure the logger of the library and run the thermostat_monitor function. application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import logging from pathlib import Path from examples.library import thermostat_monitor from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"INFO\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . setLevel ( \"DEBUG\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): log . info ( \"Hello from mcap-logger-tutorial!\" ) thermostat_monitor () if __name__ == \"__main__\" : main () When we run the application, then we should see the info and warning messages, and in the .mcap file we should see all the log messages.","title":"Using MCAP Logging In Libraries"},{"location":"tutorials/using-mcap-logging-in-libraries/#using-mcap-logging-in-libraries","text":"This tutorial will show you how the logging should be handled in libraries.","title":"Using MCAP Logging in Libraries"},{"location":"tutorials/using-mcap-logging-in-libraries/#setup-our-tutorial-project","text":"In this tutorial we will use uv . Let's create a new uv project and add the MCAP Logger package as dependency. uv init mcap_logger_tutorial cd mcap_logger_tutorial uv add mcap-logger After this we should have the following elements in the project's folder: . \u251c\u2500\u2500 .python-version \u251c\u2500\u2500 README.md \u251c\u2500\u2500 hello.py \u2514\u2500\u2500 pyproject.toml We will replace the hello.py script with application.py adn library.py . application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import logging from pathlib import Path from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"WARNING\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): # noqa: ANN201 log . info ( \"Hello from mcap-logger-tutorial!\" ) if __name__ == \"__main__\" : main () The application.py is just our examples/hello.py example, and it only logs a log message. library.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 110 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def get_thermostat_data (): for data in THERMOSTAT_DATA : humidity = data [ \"humid\" ] if humidity < 0 or humidity > 100 : print ( \"invalid humidity!\" ) else : yield data if __name__ == \"__main__\" : for data in get_thermostat_data (): print ( data ) The library.py is a modification of our examples/thermostat.py script. In this version we have the get_thermostat_data function, that yields back the data from the THERMOSTAT_DATA array, when the data is valid. If the humidity is out of boundaries then it will print a message to the console. We can run this library example with uv run library.py and see the printed out data and the error message. { 'temp' : 10 , 'humid' : 70 } { 'temp' : 5 , 'humid' : 75 } { 'temp' : 2 , 'humid' : 78 } invalid humidity! { 'temp' : 3 , 'humid' : 79 }","title":"Setup our tutorial project"},{"location":"tutorials/using-mcap-logging-in-libraries/#import-our-library-into-our-application","text":"Now, we will import this simple library into our application, and call its get_thermostat_data function in a for-loop. We will also simulate the time passing with a time.sleep call. After the log.info call we should add the following code. application.py for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"fetching data from thermostat\" ) When we run this code that we can see the warning message on the console and that the .mcap log file was created with all the log messages we created except the library's logs. However, using print statements should be avoided, so we have to create a logger for our library.","title":"Import our library into our application"},{"location":"tutorials/using-mcap-logging-in-libraries/#creating-logger-for-our-library","text":"Info Python's Logging HOWTO guide has a nice documentation on how to configure logging for a library The application developer knows their target audience and what handlers are most appropriate for their application. So we have to give the application full control over how the library does the logging. Our library should create a logger with a unique and easily identifiable name, and we should not add any handlers to it other than NullHandler . A NullHandler is a 'do nothing' handler, and we can use it to assure that our logger won't fall back to the LastResort handler. Loggers are hierarchical, and they inherit configurations from the top-level logger. If all logging by a library foo is done using loggers with names matching foo.x , foo.y , etc. then we can configure the NullHandler only for the top-level logger of the library like the following code. import logging logging . getLogger ( 'foo' ) . addHandler ( logging . NullHandler ()) In our case, we have only one library script, so we will configure our logger in it. In the library.py we import the logging package and create our logger instance called by library . Then we add the NullHandler to the library's logger. Tip Use a logger with a unique and easily identifiable name, such as the __name__ for your library\u2019s top-level package or module. library.py import logging log = logging . getLogger ( \"library\" ) log . addHandler ( logging . NullHandler ()) Then we should replace the print statements with logger calls. library.py log . warning ( \"invalid humidity!\" ) and library.py log . info ( data ) If we run now our library standalone, we can see that no output is generated on the console. This is because all the logs are handed over to the NullHandler which discards them. We can change this behavior for the standalone run if we change the configuration of the logger when we only run the library script. The code belows shows how our library script should look like after the changes. library.py import logging log = logging . getLogger ( \"library\" ) log . addHandler ( logging . NullHandler ()) THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 78 }, { \"temp\" : - 1 , \"humid\" : 110 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def get_thermostat_data (): for data in THERMOSTAT_DATA : humidity = data [ \"humid\" ] if humidity < 0 or humidity > 100 : log . warning ( \"invalid humidity!\" ) else : yield data if __name__ == \"__main__\" : stream_handler = logging . StreamHandler () stream_handler . setLevel ( logging . DEBUG ) logging . getLogger ( \"library\" ) . addHandler ( stream_handler ) logging . getLogger ( \"library\" ) . setLevel ( logging . DEBUG ) for data in get_thermostat_data (): log . info ( data ) Note Loggers are singletons , this means the only one instance of a logger with a given name exists. When you call the getLogger function with an existing name, then it will return that singleton.","title":"Creating logger for our library"},{"location":"tutorials/using-mcap-logging-in-libraries/#configure-the-library-logger-from-application","text":"Now, that we have library with logging, we have to configure its logger from our application if we want to use it. We have many possibilities on how we could configure the logger, for now, let's say that we want the library to use the same level of logging as the application logger, and it should also log to the same file. We will add this configuration step into our get_logger function, where we defined the StreamHandler and McapHandler for our application logging. We just have to add the same handler to the library's logger as follows. application.py def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger When we run the application now, we should see all the log messages on the console and in the .mcap file. applciation.mcap [ INFO ][ 12 :40:34.683 PM CET ][ application ] : Hello from mcap-logger-tutorial! [ DEBUG ][ 12 :40:35.184 PM CET ][ application ] : fetching data from thermostat [ DEBUG ][ 12 :40:35.684 PM CET ][ application ] : fetching data from thermostat [ DEBUG ][ 12 :40:36.184 PM CET ][ application ] : fetching data from thermostat [ WARN ][ 12 :40:36.184 PM CET ][ library ] : invalid humidity! [ DEBUG ][ 12 :40:36.684 PM CET ][ application ] : fetching data from thermostat As you can see, this approach gives us plenty of opportunity to fine tune the logging behaviour of our library from our application. We configure the library logger to only log higher severity message on the console and the mcap file. Or log into a different mcap file or not to do file logging at all. The choice is in the application developer to figure out what makes sense for them. Take care to document how your library uses logging - for example, the names of loggers used.","title":"Configure the library logger from application"},{"location":"tutorials/using-mcap-logging-in-libraries/#adding-data-logging","text":"Following the rule of thumb for how to configure library logging, we can see that we should not let our library populate our system with data log files whenever we run it. As before this should be up to the application developer. To achieve this we should follow the following rules: Functions that don't run as a process, must not create topic logs. Functions that run as a process, should create topic logs. ProtoBuf file should be provided for topic logs. Let's see two scenarios to see the difference.","title":"Adding data logging"},{"location":"tutorials/using-mcap-logging-in-libraries/#data-logging-from-application","text":"Given that we have the following aplication.py script. application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import logging import time from pathlib import Path from examples.library import get_thermostat_data from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): log . info ( \"Hello from mcap-logger-tutorial!\" ) for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"fetching data from thermostat\" ) if __name__ == \"__main__\" : main () Let's say that we want to log the thermostat data from our application to the mcap file. In this case, we should import the PotoBuf script of the thermostat data into our applicaton.py script and call the TopicLogger from there. application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import logging import time from pathlib import Path from examples.library import get_thermostat_data from examples.thermostat_data_pb2 import ThermostatData from mcap_logger.mcap_handler import McapHandler from mcap_logger.topic_logger import TopicLogger def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"DEBUG\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): log . info ( \"Hello from mcap-logger-tutorial!\" ) for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"fetching data from thermostat\" ) data_log = ThermostatData ( temperature = data [ \"temp\" ], humidity = data [ \"humid\" ]) TopicLogger ( \"mcap_logger\" ) . topic ( \"/thermostat\" ) . write ( data_log ) if __name__ == \"__main__\" : main () In this scenario, the library is only used to get the data from our \"sensor\", and because of this it is the applications choice and responsibility to log it.","title":"Data logging from application"},{"location":"tutorials/using-mcap-logging-in-libraries/#data-logging-from-library","text":"It is possible that the library has functions that can be imported and run as a process by other scripts. For example, lets add a thermostat_monitor to our library, that fetches the data from the thermostat, logs the data and creates a warning log if the temperature is below zero. library.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import logging import time from examples.thermostat_data_pb2 import ThermostatData from mcap_logger.topic_logger import TopicLogger log = logging . getLogger ( \"library\" ) log . addHandler ( logging . NullHandler ()) THERMOSTAT_DATA = [ { \"temp\" : 10 , \"humid\" : 70 }, { \"temp\" : 5 , \"humid\" : 75 }, { \"temp\" : 2 , \"humid\" : 789 }, { \"temp\" : - 1 , \"humid\" : 80 }, { \"temp\" : 3 , \"humid\" : 79 }, ] def get_thermostat_data (): for data in THERMOSTAT_DATA : humidity = data [ \"humid\" ] if humidity < 0 or humidity > 100 : log . warning ( \"invalid humidity!\" ) else : yield data def thermostat_monitor (): for data in get_thermostat_data (): time . sleep ( 0.5 ) log . debug ( \"got data from thermostat\" ) if data [ \"temp\" ] < 0 : log . warning ( \"temperature is below zero\" ) data_log = ThermostatData ( temperature = data [ \"temp\" ], humidity = data [ \"humid\" ]) TopicLogger ( \"library\" ) . topic ( \"/thermostat\" ) . write ( data_log ) if __name__ == \"__main__\" : stream_handler = logging . StreamHandler () stream_handler . setLevel ( logging . DEBUG ) logging . getLogger ( \"library\" ) . addHandler ( stream_handler ) logging . getLogger ( \"library\" ) . setLevel ( logging . DEBUG ) thermostat_monitor () The monitor function can be imported by another script and run it as a process until all the data is fetched. In this case, the monitor function does the logging, but only if the given logger name has an McapHandler added to it. If no, then the topic log will be discarded. From the application side, we will configure the logger of the library and run the thermostat_monitor function. application.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import logging from pathlib import Path from examples.library import thermostat_monitor from mcap_logger.mcap_handler import McapHandler def get_logger ( name : str , file : Path ) -> logging . Logger : logger = logging . getLogger ( name ) mcap_handler = McapHandler ( file ) mcap_handler . setLevel ( \"DEBUG\" ) stream_handler = logging . StreamHandler () stream_handler . setLevel ( \"INFO\" ) logger . addHandler ( mcap_handler ) logger . addHandler ( stream_handler ) logger . setLevel ( \"DEBUG\" ) library_logger = logging . getLogger ( \"library\" ) library_logger . setLevel ( \"DEBUG\" ) library_logger . addHandler ( stream_handler ) library_logger . addHandler ( mcap_handler ) return logger log_file = Path ( \"application.mcap\" ) log = get_logger ( \"mcap_logger\" , log_file ) def main (): log . info ( \"Hello from mcap-logger-tutorial!\" ) thermostat_monitor () if __name__ == \"__main__\" : main () When we run the application, then we should see the info and warning messages, and in the .mcap file we should see all the log messages.","title":"Data logging from library"}]}